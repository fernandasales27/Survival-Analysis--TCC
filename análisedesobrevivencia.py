# -*- coding: utf-8 -*-
"""AnáliseDeSobrevivencia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-0lmV9BTJTdgcKyUxfQcDuqaTJoj19Ya
"""

pip install lifelines

import pandas as pd
import numpy as np
from lifelines import CoxPHFitter
import matplotlib.pyplot as plt
from lifelines import KaplanMeierFitter
from lifelines.statistics import logrank_test
from datetime import datetime

df = pd.read_csv(
    '/content/Query_Pesquisa_Verlaynne_PalmaresBaseDataConvertida.csv',
    encoding='ISO-8859-1',
    sep=';',
    quotechar='"',
    engine='python',        # mais tolerante com formatação ruim
    on_bad_lines='skip',    # ignora linhas corrompidas (opcional)
      # para prevenir warning de tipos mistos
)

pd.set_option('display.max_columns', None)

df.columns

df.head()

df.shape

# Ler os cod_matricula do arquivo txt
with open('cod_matriculas_negativos.txt', 'r') as f:
    lista_cod_matricula = [line.strip() for line in f]

# Converter para int se necessário
lista_cod_matricula = [int(cod) for cod in lista_cod_matricula]

# Remover as linhas do DataFrame que possuem esses cod_matricula
df = df[~df['cod_matricula'].isin(lista_cod_matricula)]

# Exibir resultado Com Alunos Formatos
display(df)

df.shape #REMOÇÃO CONCLUIDA COM SUCESSO

print(df['Per. Let. Ingresso'].unique())

#print("Min:", df['Per. Let. Ingresso'].min())
#print("Max:", df['Per. Let. Ingresso'].max())

df['Situação Matrícula'].unique()

print(df['DESCRICAO_CURSO'].unique())



df.info()

df.shape

df.columns

df['Sexo'].unique()

df['Nivel_Ensino'].unique()

df['Situação Matrícula'].unique()

"""Básico= proeja. Optamos por não trabalhar com dados do proeja"""

df = df[df['Nivel_Ensino'] != 'Básico']

df.shape

# Verificar tipos e nulos
df.info()
df.isnull().sum().sort_values(ascending=False)

df['Último Evento de Matrícula'].isna().sum()
# Filtrar e mostrar apenas as linhas onde 'Último Evento de Matrícula' está vazia
linhas_vazias = df[df['Último Evento de Matrícula'].isna()]
linhas_vazias.head()

df['Per. Let. Ingresso'].value_counts()

df['Dt_Conclusao_Curso'].value_counts()

import pandas as pd
import numpy as np
import re

# ===============================
# 1. Situações de interesse
# ===============================
situacoes_desejadas = [
    'Matriculado', 'Aguardando ENADE', 'Concludente', 'Concluído', 'Estagiario (Concludente)',
    'Projeto Final (Concludente)', 'Trancado', 'Matrícula Vínculo Institucional',
    'Formado', 'concluido', 'Aguardando Colação de Grau'
]

situacoes_evasao = [
    'Abandono/Evasão', 'Cancelamento Voluntário', 'Cancelamento Compulsório',
    'Falecido', 'Transferido Interno', 'Transferido Externo', 'Jubilado'
]

# ===============================
# 2. DATAS
# ===============================

# Converter colunas de data
df['Dt_Conclusao_Curso'] = pd.to_datetime(df['Dt_Conclusao_Curso'], dayfirst=True, errors='coerce')
df['Per. Let. Ingresso'] = pd.to_datetime(df['Per. Let. Ingresso'], dayfirst=True, errors='coerce')
df.rename(columns={'Per. Let. Ingresso': 'Data_Ingresso'}, inplace=True)

# Criar cópia da data de conclusão
df['Copia_Dt_Conclusao_Curso'] = df['Dt_Conclusao_Curso']

# Preencher 06/2025 para casos "sobreviventes" sem data
mascara_sobreviventes = df['Situação Matrícula'].str.lower().isin([s.lower() for s in situacoes_desejadas]) & df['Copia_Dt_Conclusao_Curso'].isna()
df.loc[mascara_sobreviventes, 'Copia_Dt_Conclusao_Curso'] = pd.Timestamp('2025-06-01')

# Extrair data do texto de último evento (casos de evasão)
def extrair_data_texto(texto):
    if pd.isna(texto):
        return pd.NaT
    match = re.search(r'\d{2}/\d{2}/\d{4}', str(texto))
    if match:
        return pd.to_datetime(match.group(0), dayfirst=True, errors='coerce')
    return pd.NaT

df['Data_Ultimo_Evento'] = df['Último Evento de Matrícula'].apply(extrair_data_texto)

# Preencher data para casos de evasão
mascara_evasao = df['Situação Matrícula'].isin(situacoes_evasao) & df['Copia_Dt_Conclusao_Curso'].isna()
df.loc[mascara_evasao, 'Copia_Dt_Conclusao_Curso'] = df.loc[mascara_evasao, 'Data_Ultimo_Evento']

# Garantir datetime nas datas finais
df['Copia_Dt_Conclusao_Curso'] = pd.to_datetime(df['Copia_Dt_Conclusao_Curso'], errors='coerce')
df['Data_Ingresso'] = pd.to_datetime(df['Data_Ingresso'], errors='coerce')

# ===============================
# 3. TEMPO (Meses Matriculado)
# ===============================
def calcular_meses(data_inicio, data_fim):
    if pd.isna(data_inicio) or pd.isna(data_fim):
        return np.nan
    return (data_fim.year - data_inicio.year) * 12 + (data_fim.month - data_inicio.month)

df['MesesMatriculado'] = df.apply(
    lambda row: calcular_meses(row['Data_Ingresso'], row['Copia_Dt_Conclusao_Curso']),
    axis=1
)

# ===============================
# 4. EVENTO (0 = censura, 1 = evasão)
# ===============================
df['evento'] = df['Situação Matrícula'].isin(situacoes_evasao).astype(int)

# ===============================
# 5. FILTRO de alunos que excederam o tempo esperado (2x duração)
# ===============================
df['Qtd Períodos'] = pd.to_numeric(df['Qtd Períodos'], errors='coerce').fillna(0)

cond_integrado = df['Qtd Períodos'] <= 4
df['LimiteMaximoMeses'] = np.where(
    cond_integrado,
    df['Qtd Períodos'] * 12 * 2,
    df['Qtd Períodos'] * 6 * 2
)

# Exportar os excluídos por tempo
df_excluidos = df[df['MesesMatriculado'] > df['LimiteMaximoMeses']].copy()

# Filtrar base final
df = df[df['MesesMatriculado'] <= df['LimiteMaximoMeses']].copy()

# ===============================
# 6. Exibir resultado final
# ===============================
print("Total de registros:", len(df))
print("Excluídos por ultrapassar tempo máximo:", len(df_excluidos))
#print("Registros finais para análise:", len(df_final))
#print(df_final[['Cod_Aluno', 'MesesMatriculado', 'evento']].head())

df.shape

df_excluidos.shape

df['LimiteMaximoMeses']

df['Data_Ingresso'].value_counts()

df['Copia_Dt_Conclusao_Curso'].value_counts()

# Verifique os casos com meses negativos
negativos = df[df['MesesMatriculado'] < 0][['Cod_Aluno', 'Data_Ingresso', 'Copia_Dt_Conclusao_Curso', 'MesesMatriculado']]
print(f"Registros com tempo negativo: {len(negativos)}")
display(negativos.head())

# Filtrar registros com tempo negativo
df_negativos = df[df['MesesMatriculado'] < 0][['Cod_Aluno', 'cod_matricula', 'Data_Ingresso', 'Copia_Dt_Conclusao_Curso', 'MesesMatriculado']]

# Exibir resultado
print(f"Total de registros com MesesMatriculado negativo: {len(df_negativos)}")
display(df_negativos)

lista_cod_matricula = df_negativos['cod_matricula'].tolist()

len(lista_cod_matricula)

with open('cod_matriculas_negativos.txt', 'w') as f:
    for cod in lista_cod_matricula:
        f.write(str(cod) + '\n')

# Passo 3 – Criar coluna "evento" com base na Situação Matrícula
sobrevivencia = [
    'Matriculado', 'Aguardando ENADE', 'Concludente', 'Concluído', 'Estagiario (Concludente)',
    'Projeto Final (Concludente)', 'Trancado', 'Matrícula Vínculo Institucional',
    'Formado', 'concluido', 'Aguardando Colação de Grau'
]
evento = [
    'Abandono/Evasão', 'Cancelamento Voluntário', 'Cancelamento Compulsório',
    'Falecido', 'Transferido Interno', 'Transferido Externo', 'Jubilado'
]
df['evento'] = df['Situação Matrícula'].apply(lambda x: 1 if x in evento else 0)

print(df['MesesMatriculado'].isnull().sum())  # 'Data_Ingresso' 'Copia_Dt_Conclusao_Curso' Resolvi apagar pois esses 4 elementos só tinha a data_ingresso e nenhuma forma de validar sua evasão!
print()
df[df['MesesMatriculado'].isnull()]
df = df.dropna(subset=['MesesMatriculado'])
print(df['MesesMatriculado'].isnull().sum())

df['MesesMatriculado']

df['LimiteMaximoMeses'].max()

df[df['MesesMatriculado'] > 96]

print(df[df['MesesMatriculado'] < 0][['Cod_Aluno', 'Data_Ingresso', 'Copia_Dt_Conclusao_Curso', 'MesesMatriculado']])

from lifelines import KaplanMeierFitter
import matplotlib.pyplot as plt

# Instanciar o modelo
kmf = KaplanMeierFitter()

# Ajustar o modelo aos seus dados
kmf.fit(durations=df['MesesMatriculado'], event_observed=df['evento'])

# Plotar a curva de sobrevivência
kmf.plot_survival_function()
plt.title('Probabilidade de Permanência no Curso')
plt.ylabel('Probabilidade de Sobrevivência')
plt.xlabel('Tempo (meses)')
plt.grid(True)
plt.show()

df['MesesMatriculado'].isnull().sum()

df['evento'].isnull().sum()

df.columns

df.shape

df = df.drop(columns=['Cod_Aluno', 'cod_matricula','Matricula','Cod_instituicao', 'Pólo Municipal', 'Turno Ingresso',
                      'Regime Internato', 'Grupo Étnico','Area Procedência Escola Origem','C.E.P.','Bairro','Cod_cidade',
                     'Percentual Frequencia', 'Ano_Conclusao_Ensino_Medio','necessidades_especiais','N_Membros_Familia', 'Cod_Nacionalidade','EIXO_TECNOLÓGICO',
                     'Renda Familiar', 'Renda Familiar Per Capita SIG', 'Renda Familiar Per Capita PNP', 'Cod_curso','Desc_Forma_Ingresso_Matricula','Última Presença'])

df.shape

df.columns

print("Nulos em MesesMatriculado:", df['MesesMatriculado'].isna().sum())
print("Nulos em evento:", df['evento'].isna().sum())

# Filtrar e mostrar os 4 alunos com MesesMatriculado nulo
alunos_nulos = df[df['MesesMatriculado'].isna()]

# Exibir todas as colunas disponíveis desses alunos
pd.set_option('display.max_columns', None)  # Mostra todas as colunas
display(alunos_nulos)

df.shape

df = pd.get_dummies(df, columns=['Sexo', 'Turno', 'Cota', 'Cor/Raça'], drop_first=True, prefix_sep='_')

import pandas as pd

# Converter colunas para datetime
df['Nascimento'] = pd.to_datetime(df['Nascimento'], format='%d/%m/%Y', errors='coerce')
df['Data_Ingresso'] = pd.to_datetime(df['Data_Ingresso'], format='%d/%m/%Y', errors='coerce')

# Extrair ano de ingresso
df['Ano_Ingresso'] = df['Data_Ingresso'].dt.year

# Calcular idade no momento do ingresso
df['Idade_Ingresso'] = df['Data_Ingresso'].dt.year - df['Nascimento'].dt.year

# Exibir o resultado
display(df[[ 'Nascimento', 'Data_Ingresso', 'Ano_Ingresso', 'Idade_Ingresso']])

df.groupby(['Situação Matrícula', 'evento']).size().reset_index(name='Total')

# Passo 1: Substituir vírgula por ponto e converter
df['Coeficiente_Rendimento'] = (
    df['Coeficiente_Rendimento']
    .astype(str)
    .str.replace(',', '.')
    .replace('nan', np.nan)
    .astype(float)
)

# Passo 2: Verificar outliers
print("Estatísticas descritivas:")
print(df['Coeficiente_Rendimento'].describe())

cols_raca = ['Cor/Raça_Branca', 'Cor/Raça_Parda', 'Cor/Raça_Preta', 'Cor/Raça_Indígena', 'Cor/Raça_Não dispõe da informação', 'Cor/Raça_Não quis declarar cor/raça']

def pega_raca(row):
    for col in cols_raca:
        if row[col] == 1:
            return col.replace('Cor/Raça_', '')
    return 'Desconhecido'

df['Cor_Raca_Grupo'] = df.apply(pega_raca, axis=1)

from lifelines import KaplanMeierFitter
from lifelines.statistics import multivariate_logrank_test
import matplotlib.pyplot as plt

grupos = df['Cor_Raca_Grupo'].unique()
kmf = KaplanMeierFitter()

plt.figure(figsize=(10,6))
for grupo in grupos:
    mask = df['Cor_Raca_Grupo'] == grupo
    kmf.fit(df.loc[mask, 'MesesMatriculado'], event_observed=df.loc[mask, 'evento'], label=grupo)
    kmf.plot_survival_function()

plt.title('Curvas de Sobrevivência por Cor/Raça')
plt.xlabel('Tempo (meses)')
plt.ylabel('Probabilidade de Permanência')
plt.legend()
plt.show()

results = multivariate_logrank_test(df['MesesMatriculado'], df['Cor_Raca_Grupo'], event_observed=df['evento'])
print(results.summary)
print(f'p-valor do teste log-rank multigrupos: {results.p_value:.4f}')

from lifelines import KaplanMeierFitter
import matplotlib.pyplot as plt

kmf = KaplanMeierFitter()

# Dados para Sexo Masculino
mask_m = df['Sexo_M'] == 1
kmf.fit(durations=df.loc[mask_m, 'MesesMatriculado'], event_observed=df.loc[mask_m, 'evento'], label='Masculino')
ax = kmf.plot_survival_function()

# Dados para Sexo Feminino
mask_f = df['Sexo_M'] == 0
kmf.fit(durations=df.loc[mask_f, 'MesesMatriculado'], event_observed=df.loc[mask_f, 'evento'], label='Feminino')
kmf.plot_survival_function(ax=ax)

plt.title('Probabilidade de Permanência no Curso por Sexo')
plt.xlabel('Tempo (meses)')
plt.ylabel('Probabilidade de Sobrevivência')
plt.show()

evento = [
    'Abandono/Evasão', 'Cancelamento Voluntário', 'Cancelamento Compulsório',
    'Falecido', 'Transferido Interno', 'Transferido Externo', 'Jubilado'
]

df['evento'] = df['Situação Matrícula'].isin(evento).astype(int)
print(df['evento'].value_counts())

df_cox_final.shape

df_cox_final.columns

df = pd.get_dummies(df, columns=['Nível/Regime de Ensino'], drop_first=True, prefix_sep='_')

df.columns

# Substituir vírgulas por pontos e converter todas as colunas numéricas
for col in df.columns:
    if df[col].dtype == 'object':
        try:
            df[col] = df[col].str.replace(',', '.', regex=False).astype(float)
        except:
            pass  # Ignora colunas que não são numéricas mesmo

from lifelines import CoxPHFitter


cols_modelo = ['MesesMatriculado', 'evento', 'Idade_Ingresso', 'Sexo_M', 'Turno_Matutino', 'Turno_Noturno', 'Coeficiente_Rendimento','Cor/Raça_Branca', 'Cor/Raça_Indígena',
       'Cor/Raça_Não dispõe da informação',
       'Cor/Raça_Não quis declarar cor/raça', 'Cor/Raça_Parda',
       'Cor/Raça_Preta', 'Nível/Regime de Ensino_Integrado',
       'Nível/Regime de Ensino_Licenciatura Plena',
       'Nível/Regime de Ensino_Subseqüente',
       'Nível/Regime de Ensino_Tecnólogo']

df_cox_final = df[cols_modelo].dropna()

cph = CoxPHFitter()
cph.fit(df_cox_final, duration_col='MesesMatriculado', event_col='evento')
cph.print_summary()

cols_modelo = ['MesesMatriculado', 'evento', 'Idade_Ingresso', 'Sexo_M', 'Turno_Matutino', 'Turno_Noturno', 'Coeficiente_Rendimento']
df[cols_modelo].isnull().sum()

import matplotlib.pyplot as plt
import seaborn as sns
from lifelines import CoxPHFitter

# Estilo visual
sns.set(style="whitegrid")

# Ajustar o modelo
cph = CoxPHFitter()
cph.fit(df_cox_final, duration_col='MesesMatriculado', event_col='evento')

# Plotar Forest Plot

fig, ax = plt.subplots(figsize=(10, 6))
cph.plot(hazard_ratios=True, ax=ax)
ax.set_title("Hazard Ratios (HR) - Modelo de Cox", fontsize=14)
plt.tight_layout()
plt.axvline(x=1, color='gray', linestyle='--', linewidth=0.8, label='HR = 1 (Nenhum efeito)')
plt.legend()
plt.show()

df.to_csv('df_cox_final.csv', index=False)

df.shape

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='Coeficiente_Rendimento', y='MesesMatriculado')
plt.title('Coeficiente de Rendimento vs Tempo de Matrícula (em meses)')
plt.xlabel('Coeficiente de Rendimento')
plt.ylabel('Meses Matriculado')
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(
    data=df,
    x='Coeficiente_Rendimento',
    y='MesesMatriculado',
    hue='Sexo_M'
)
plt.title('Rendimento vs Tempo de Matrícula por Sexo')
plt.xlabel('Coeficiente de Rendimento')
plt.ylabel('Meses Matriculado')
plt.legend(title='Sexo (1=Masculino)')
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(
    data=df,
    x='Coeficiente_Rendimento',
    y='MesesMatriculado',
    hue='Turno_Noturno'
)
plt.title('Rendimento vs Tempo de Matrícula por Turno Noturno')
plt.xlabel('Coeficiente de Rendimento')
plt.ylabel('Meses Matriculado')
plt.legend(title='Turno Noturno (1=Sim)')
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(
    data=df[(df['Cor/Raça_Parda'] == 1) | (df['Cor/Raça_Preta'] == 1)],
    x='Coeficiente_Rendimento',
    y='MesesMatriculado',
    hue='Cor/Raça_Parda'
)
plt.title('Rendimento vs Tempo de Matrícula (Pardos x Pretos)')
plt.xlabel('Coeficiente de Rendimento')
plt.ylabel('Meses Matriculado')
plt.legend(title='1 = Parda, 0 = Preta')
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(
    data=df,
    x='Coeficiente_Rendimento',
    y='MesesMatriculado',
    hue='Nível/Regime de Ensino_Tecnólogo'
)
plt.title('Rendimento vs Tempo de Matrícula (Tecnólogo vs outros)')
plt.xlabel('Coeficiente de Rendimento')
plt.ylabel('Meses Matriculado')
plt.legend(title='Tecnólogo (1=Sim)')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Criando uma nova coluna de curso (uma string com nome)
def identificar_curso(row):
    if row['Nível/Regime de Ensino_Integrado'] == 1:
        return 'Integrado'
    elif row['Nível/Regime de Ensino_Licenciatura Plena'] == 1:
        return 'Licenciatura'
    elif row['Nível/Regime de Ensino_Subseqüente'] == 1:
        return 'Subsequente'
    elif row['Nível/Regime de Ensino_Tecnólogo'] == 1:
        return 'Tecnólogo'
    else:
        return 'Outro'

df['Tipo_Curso'] = df.apply(identificar_curso, axis=1)

# Criando o gráfico
plt.figure(figsize=(12, 7))
sns.scatterplot(
    data=df,
    x='Coeficiente_Rendimento',
    y='MesesMatriculado',
    hue='Sexo_M',            # 1 = masculino, 0 = feminino
    style='Tipo_Curso',      # Diferenciar os tipos de curso
    palette='Set1'
)

plt.title('Tempo de Matrícula vs. Rendimento por Sexo e Tipo de Curso')
plt.xlabel('Coeficiente de Rendimento')
plt.ylabel('Meses Matriculado')
plt.legend(title='Sexo (1=M) / Tipo de Curso')
plt.grid(True)
plt.tight_layout()
plt.show()

variaveis = [
    'Idade_Ingresso', 'Sexo_M', 'Turno_Matutino', 'Turno_Noturno',
    'Coeficiente_Rendimento', 'Cor/Raça_Branca', 'Cor/Raça_Indígena',
    'Cor/Raça_Não dispõe da informação', 'Cor/Raça_Não quis declarar cor/raça',
    'Cor/Raça_Parda', 'Cor/Raça_Preta', 'Nível/Regime de Ensino_Integrado',
    'Nível/Regime de Ensino_Licenciatura Plena', 'Nível/Regime de Ensino_Subseqüente',
    'Nível/Regime de Ensino_Tecnólogo'
]

for var in variaveis:
    print(f"\n=== {var} ===")
    print(df[var].value_counts(dropna=False))  # Frequência absoluta (inclusive NaN)
    print(df[var].value_counts(normalize=True, dropna=False).apply(lambda x: f"{x*100:.2f}%"))  # Percentual
    print(f"Total de valores nulos: {df[var].isna().sum()} de {len(df)}")

"""# Por nivel de ensino"""

df_superiores = df[df['Desc_Modalidade_Curso'].isin(['Tecnólogo', 'Bacharelado', 'Licenciatura'])].copy()

df['Grupo_Curso'] = np.where(
    df['Desc_Modalidade_Curso'].isin(['Tecnólogo', 'Bacharelado', 'Licenciatura']),
    'Curso Superior',
    'Curso Técnico'
)

df['Grupo_Curso'].value_counts()

colunas_modelo = [
    'MesesMatriculado',
    'evento',
    'Idade_Ingresso',
    'Coeficiente_Rendimento',
    'Sexo_M',          # se tiver usado get_dummies
    'Turno_Matutino',
    'Turno_Noturno','Cor/Raça_Branca', 'Cor/Raça_Indígena',
       'Cor/Raça_Não dispõe da informação',
       'Cor/Raça_Não quis declarar cor/raça', 'Cor/Raça_Parda',
       'Cor/Raça_Preta'
    # você pode incluir outras se quiser, como cor/raça
]
df_modelo = df_superiores[colunas_modelo].dropna()

from lifelines import CoxPHFitter

cph = CoxPHFitter()
cph.fit(df_modelo, duration_col='MesesMatriculado', event_col='evento')
cph.print_summary()

df_modelo.columns

import matplotlib.pyplot as plt
import seaborn as sns
from lifelines import CoxPHFitter

# Estilo visual
sns.set(style="whitegrid")

# Ajustar o modelo
cph = CoxPHFitter()
cph.fit(df_modelo, duration_col='MesesMatriculado', event_col='evento')

# Plotar Forest Plot

fig, ax = plt.subplots(figsize=(10, 6))
cph.plot(hazard_ratios=True, ax=ax)
ax.set_title("Hazard Ratios (HR) - Modelo de Cox", fontsize=14)
plt.tight_layout()
plt.axvline(x=1, color='gray', linestyle='--', linewidth=0.8, label='HR = 1 (Nenhum efeito)')
plt.legend()
plt.show()